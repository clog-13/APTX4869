# 12.状态码

正确地理解并应用状态码不是客户端或服务器单方的责任，而是双方共同的责任。

客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。

服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返 400、500 这样意思含糊不清的状态码。

目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。

## 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；

**“101 Switching Protocols”**它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。

## 2××：成功，报文已经收到并被正确处理；

  **“204 No Content”**是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。

**“206 Partial Content”**是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着**头字段“Content-Range”，表示响应报文里 body 数据的具体范围**，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。

## 3××：重定向，资源位置发生变动，需要客户端重新发送请求；

**“301 Moved Permanently”**俗称**“永久重定向”**，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。

**“302 Found”**，曾经的描述短语是“Moved Temporarily”，俗称**“临时重定向”**，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。

301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI。

**“304 Not Modified”** 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，**用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”**（即**“缓存重定向”**）。

**“308Permanent Redirect”**和**“307 TemporaryRedirect”**，但这两个状态码不允许后续的请求更改请求方法。

## 4××：客户端错误，请求报文有误，服务器无法处理；

**“400 Bad Request”**是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。

**“403 Forbidden”**实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。

**405 Method Not Allowed**：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；

**406 Not Acceptable**：资源无法满足客户端请求的条件，例如请求中文但只有英文；

**408 Request Timeout**：请求超时，服务器等待了过长的时间；

**409 Conflict**：多个请求发生了冲突，可以理解为多线程并发时的竞态；

**413 Request Entity Too Large**：请求报文里的 body 太大；

**414 Request-URI Too Long**：请求行里的 URI 太大；

**429 Too Many Requests**：客户端发送了太多的请求，通常是由于服务器的限连策略；

**431 Request Header Fields Too Large**：请求头某个字段或总体太大；

## 5××：服务器错误，服务器在处理请求时内部发生了错误。

**“500 Internal Server Error”**与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。

**“501 Not Implemented”**表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多。

**“502 Bad Gateway”**通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。

**“503 Service Unavailable”**表示服务器当前很忙，**暂时**无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 **503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。**

# HTTP特点

- HTTP 是**灵活可扩展**的，可以任意添加头字段实现任意功能；

- HTTP 是**可靠传输协议**，基于 TCP/IP 协议“尽量”保证数据的送达；

- HTTP 是**应用层协议**，比 FTP、SSH 等更通用功能更多，能够传输任意数据；

- HTTP 使用了**请求 - 应答模式**，客户端主动发起请求，服务器被动回复请求；

- HTTP 本质上是**无状态**的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。

如果要100%保证数据收发成功就不能使用HTTP或者TCP协议了，而是要用各种消息中间件(MQ), 如 RabbitMQ、ZeroMQ、Kafka等。

出于安全的原因，绝大多数网站都封禁了80/8080以外的端口号,只允许HTTP协议“穿透”，这也是造成HTTP流行的客观原因之一。

HTTP/1.1以文本格式传输header，有严重的数据冗余，也影响了它的性能。

# HTTP的实体数据

### 数据类型与编码

而 HTTP 协议则不同，它是应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，否则上层应用就会“不知所措”。

在 HTTP 协议诞生之前就已经有了针对这种问题的解决方案，在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。

MIME 是一个很大的标准规范，但 HTTP 取了其中的一部分，用来标记 body 的数据类型，这就是我们平常总能听到的“MIME type”。

MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串。

- text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。

- image：即图像文件，有 image/gif、image/jpeg、image/png 等。
- audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。
- application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。

但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，**有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据。**

Encoding type 常用的只有下面三种：

- gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；

- deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；

- br：一种专门为 HTTP 优化的新压缩算法（Brotli）。

### 数据类型使用的头字段

HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“内容协商”。

**客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。**

**Accept 字段**标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，让服务器有更多的选择余地，例如下面的这个头：

```
Accept: text/html,application/xml,image/webp,image/png
```

这是告诉服务器：“我能够看懂 HTML、XML 的文本，还有 webp 和 png 的图片，请给我这四类格式的数据”。

相应的，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：

```
Content-Type: text/html
Content-Type: image/png
```

这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看到“image/png”就知道是一个 PNG 文件，就会在页面上显示出图像。

**Accept-Encoding 字段**标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应**头字段 Content-Encoding** 里。

```
Accept-Encoding: gzip, deflate, br
Content-Encoding: gzip
```

不过这两个字段是可以省略的，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据；如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩。

### 语言类型与编码

所谓的“语言类型”就是人类使用的自然语言，例如英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，所以在需要明确区分的时候也要使用“type-subtype”的形式，不过这里的格式与数据类型不同，分隔符不是“/”，而是“-”。

n 表示任意的英语，en-US 表示美式英语，en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉语。

后来出现了 **Unicode 和 UTF-8**，把世界上所有的语言都容纳在一种编码方案里，**遵循 UTF-8 字符编码方式的 Unicode 字符集也成为了互联网上的标准字符集。**

### 语言类型使用的头字段

HTTP 协议也使用 Accept 请求头字段和 Content 实体头字段，用于客户端和服务器就语言与编码进行**“内容协商”**。

**Accept-Language 字段**标记了客户端可理解的自然语言，也允许用“,”做分隔符列出多个类型，例如：

```
Accept-Language: zh-CN, zh, en
```

相应的，服务器应该在响应报文里用**头字段 Content-Language** 告诉客户端实体数据使用的实际语言类型：

```
Content-Language: zh-CN
```

字符集在 HTTP 里使用的请求**头字段是 Accept-Charset**，但响应头里却没有对应的 **Content-Charset**，而是在 **Content-Type** 字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码：

```
Accept-Charset: gbk, utf-8
Content-Type: text/html; charset=utf-8
```

现在的浏览器都支持多种字符集，通常不会发送 **Accept-Charset**，而服务器也不会发送 **Content-Language**，因为使用的语言完全可以由字符集推断出来，所以在请求头里一般只会有 **Accept-Language 字段**，响应头里只会有 **Content-Type 字段**。