#  calloc、malloc、realloc函数的区别及用法

### C语言跟内存分配方式
1. 从静态存储区域分配.
内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在.例如全局变量、static变量.
2. 在栈上创建
在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放.栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限.
3. 从堆上分配，亦称动态内存分配.
程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存.动态内存的生存期由用户决定，使用非常灵活，但问题也最多.

### C语言跟内存申请相关的函数主要有 alloca、calloc、malloc、free、realloc等.
1. alloca是向栈申请内存,因此无需释放.
2. malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.
3. calloc则将初始化这部分的内存,设置为0.
4. realloc则对malloc申请的内存进行大小的调整.
5. 申请的内存最终需要通过函数free来释放.

当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,使得系统可用内存不断减少.但是内存泄漏仅仅指程序在运行时,程序退出时,OS将回收所有的资源.因此,适当的重起一下程序,有时候还是有点作用.


### 三者都是分配内存，都是stdlib.h库里的函数，但是也存在一些差异。

（1）malloc函数。其原型void *malloc(unsigned int num_bytes)；
```cpp
int *p = (int *)malloc(20*sizeof(int));
```
num_byte为要申请的空间大小，需要我们手动的去计算，如int *p = (int *)malloc(20*sizeof(int)),如果编译器默认int为4字节存储的话，那么计算结果是80Byte，一次申请一个80Byte的连续空间，并将空间基地址强制转换为int类型，赋值给指针p,此时申请的内存值是不确定的。

（2）calloc函数，其原型void *calloc(size_t n, size_t size)；
```cpp
int *pp = (int *)calloc(20, sizeof(int));
```
其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如如果他要申请20个int类型空间，会int *p = (int *)calloc(20, sizeof(int)）,这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;

很多人会疑问：既然calloc不需要计算空间并且可以直接初始化内存避免错误，那为什么不直接使用calloc函数，那要malloc要什么用呢？
实际上，任何事物都有两面性，有好的一面，必然存在不好的地方。这就是效率。calloc函数由于给每一个空间都要初始化值，那必然效率较malloc要低，并且现实世界，很多情况的空间申请是不需要初始值的，这也就是为什么许多初学者更多的接触malloc函数的原因。

（3）realloc函数和上面两个有本质的区别，其原型void realloc(void *ptr, size_t new_Size)
```cpp
int *p = (int *)malloc(20*sizeof(int));
int *pp = (int *)realloc(p, 4000*sizeof(int));
```
用于对动态内存进行扩容(及已申请的动态空间不够使用，需要进行空间扩容操作)，ptr为指向原来空间基址的指针， new_size为接下来需要扩充容量的大小。

实际上：

如果size较小，原来申请的动态内存后面还有空余内存，系统将直接在原内存空间后面扩容，并返回原动态空间基地址；如果size较大，原来申请的空间后面没有足够大的空间扩容，系统将重新申请一块(20+4000)*sizeof(int)的内存，并把原来空间的内容拷贝过去，原来空间free;如果size非常大，系统内存申请失败，返回NULL,原来的内存不会释放。注意：如果扩容后的内存空间较原空间小，将会出现数据丢失，如果直接realloc(p, 0);相当于free(p).