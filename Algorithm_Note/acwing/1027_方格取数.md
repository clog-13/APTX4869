# 1027. 方格取数
设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。

某人从左上角出发，可以向下行走，也可以向右行走，直到到达右下角。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从起点到终点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

**输入格式**
第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从 1 开始。

一行“0 0 0”表示结束。

**输出格式**
输出一个整数，表示两条路径上取得的最大的和。

**数据范围**
N≤10
**输入样例：**
>8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0

**输出样例：**
>67

## DP
1、f[i1, j1, i2, j2]表示所有从 (1,1) 分别走到(i1,j1),(i2,j2)的路径的最大值

2、由于走两次可以看成是两条路径同时走，因此k表示两条路线当前走到的各自的横纵坐标之和k \== i1 + j1 \== i2 + j2

注意：在i1 + j1 \== i2 + j2时，两条路径走到的当前格子可能（只是可能）重合

因为 k−1 \== i1 + j1 − 1 \== i2 + j2 − 1

由f\[i1]\[j1−1]\[i2]\[j2−1] 转化为 f\[k−1]\[i1]\[i2]

同理可得：（一个格子只能被取一次）

f\[i1−1]\[j1]\[i2−1]\[j2]\==f[k−1]\[i1−1][i2−1]

f\[i1]\[j1−1]\[i2−1]\[j2]\==f[k−1]\[i1][i2−1]

f\[i1−1]\[j1]\[i2]\[j2−1]\==f[k−1]\[i1−1][i2]



f\[k]\[i1]\[i2] 表示从(1, 1)和(1, 1)分别走到(i1, k-i1)和(i2, k-i2)的路径最大值


```java
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[][] data = new int[N+1][N+1];
        int[][][] dp = new int[2*N+1][N+1][N+1];

        while (true) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            int v = sc.nextInt();
            if (x == 0 && y == 0 && v == 0) break;
            data[x][y] = v;
        }

        for (int k = 2; k <= 2*N; k++) {
            for (int i1 = 1; i1 <= N; i1++) {
                for (int i2 = 1; i2 <= N; i2++) {
                    int j1 = k - i1;
                    int j2 = k - i2;
                    if (j1 <= 0 || j1 > N || j2 <= 0 || j2 > N) continue;
                    int tmp = data[i1][j1];
                    if (i1 != i2) tmp += data[i2][j2];
                    
                    int ne = 0;
                    ne = Math.max(ne, dp[k-1][i1-1][i2-1]);
                    ne = Math.max(ne, dp[k-1][i1-1][i2]);
                    ne = Math.max(ne, dp[k-1][i1][i2-1]);
                    ne = Math.max(ne, dp[k-1][i1][i2]);
                    dp[k][i1][i2] = ne + tmp;
                }
            }
        }

        System.out.println(dp[2*N][N][N]);
    }
}
```

。