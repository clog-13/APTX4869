# 1664. 生成平衡数组的方案数

给你一个整数数组 `nums` 。你需要选择 **恰好** 一个下标（下标从 **0** 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。

比方说，如果 `nums = [6,1,7,4,1]` ，那么：

- 选择删除下标 `1` ，剩下的数组为 `nums = [6,7,4,1]` 。
- 选择删除下标 `2` ，剩下的数组为 `nums = [6,1,4,1]` 。
- 选择删除下标 `4` ，剩下的数组为 `nums = [6,1,7,4]` 。

如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 **平衡数组** 。

请你返回删除操作后，剩下的数组 `nums` 是 平衡数组 的 **方案数** 。

**示例 1：**

```
输入：nums = [2,1,6,4]
输出：1
解释：
删除下标 0 ：[1,6,4] -> 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。
删除下标 1 ：[2,6,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。
删除下标 2 ：[2,1,4] -> 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。
删除下标 3 ：[2,1,6] -> 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。
只有一种让剩余数组成为平衡数组的方案。
```

**示例 2：**

```
输入：nums = [1,1,1]
输出：3
解释：你可以删除任意元素，剩余数组都是平衡数组。
```



## 前綴和（前綴差值）

*dp*[*i*−1]表示索引i*i*左边部分奇偶元素差值，dp[n] - dp[i] 表示索引 i 右边部分奇偶元素差值

```java
class Solution {
    public int waysToMakeFair(int[] nums) {
        int N = nums.length;
        int[] dp = new int[N+1];

        for(int i = 0; i < N; ++i){
            dp[i+1] = dp[i] + (i%2==1 ? nums[i] : -nums[i]);
        }

        int res = 0;
        for(int i = 1; i <= N; ++i){
            if (dp[i-1] == dp[N] - dp[i]) res++;
        }
        return res;
    }
}
```

```java
class Solution {
    public int waysToMakeFair(int[] nums) {
        int sumOdd=0, sumEve=0, leOdd=0, leEve=0, riOdd=0, riEve=0, res=0;
        for (int i = 0; i < nums.length; i++) {
            if (i%2 == 0) sumEve += nums[i];
            else sumOdd += nums[i];
        }
        for (int i = 0; i < nums.length; i++) {
            if (i%2 == 0) leEve += nums[i];
            else leOdd += nums[i];

            riEve = sumOdd - leOdd; 
            riOdd = sumEve - leEve;
            if (i%2 == 0) riEve -= nums[i];
            else riOdd -= nums[i];

            if (leEve+riEve == leOdd+riOdd) res++;
        }
        return res;
    }
}
```

