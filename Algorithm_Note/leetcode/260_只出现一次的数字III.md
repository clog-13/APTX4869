# 260. 只出现一次的数字 III

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

**示例 :**

```
输入: [1,2,1,3,2,5]
输出: [3,5]
```

**注意：**

1. 结果输出的顺序并不重要，对于上面的例子， `[5, 3]` 也是正确答案。

2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

   

## 掩码

- 使用异或运算可以帮助我们消除出现两次的数字；我们计算 `bitmask ^= x`，则 `bitmask` 留下的就是出现奇数次的位。

- `x & (-x)` 是保留位中最右边 `1` ，且将其余的 `1` 设位 `0` 的方法。

- 首先计算 bitmask ^= x，则 bitmask 不会保留出现两次数字的值，因为相同数字的异或值为 0。

  但是 bitmask 会保留只出现一次的两个数字（x 和 y）之间的差异。

- 我们可以直接从 bitmask 中提取 x 和 y 吗？不能，但是我们可以用 bitmask 作为标记来分离 x 和 y。

  我们通过 bitmask & (-bitmask) 保留 bitmask 最右边的 1，这个 1 要么来自 x，要么来自 y。

- 当我们找到了 `x`，那么 `y = bitmask^x`。

 ```java
class Solution {
    public int[] singleNumber(int[] nums) {
        // difference between two numbers (x and y) which were seen only once
        int bitmask = 0;
        for (int num : nums) bitmask ^= num;

        // rightmost 1-bit diff between x and y
        int diff = bitmask & (-bitmask);

        int x = 0;
        // bitmask which will contain only x
        for (int num : nums) if ((num & diff) != 0) x ^= num;

        return new int[]{x, bitmask^x};
    }
}
 ```

