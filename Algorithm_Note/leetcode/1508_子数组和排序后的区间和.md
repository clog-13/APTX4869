# 1508. 子数组和排序后的区间和

给你一个数组 `nums` ，它包含 `n` 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 `n * (n + 1) / 2` 个数字的数组。

请你返回在新数组中下标为 `left` 到 `right` **（下标从 1 开始）**的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。

**示例：**
```
输入：nums = [1,2,3,4], n = 4, left = 1, right = 5
输出：13 
解释：所有的子数组和为 1, 3, 6, 10, 2, 5, 9, 3, 7, 4 。将它们升序排序后，我们得到新的数组 [1, 2, 3, 3, 4, 5, 6, 7, 9, 10] 。下标从 le = 1 到 ri = 5 的和为 1 + 2 + 3 + 3 + 4 = 13 。
```

## 二分查找 + 双指针
```java
class Solution {
    int N, MOD = 1000000007;
    int[] preSum, PPreSum;

    public int rangeSum(int[] nums, int n, int left, int right) {
        N = n;
        preSum = new int[N+1];
        for (int i = 0; i < N; i++) preSum[i+1] = preSum[i] + nums[i];
        PPreSum = new int[N+1];
        for (int i = 0; i < N; i++) PPreSum[i+1] = PPreSum[i] + preSum[i+1];

        return (getSum(right) - getSum(left-1)) % MOD;
    }

    public int getSum(int k) {
        int tar = getKth(k);

        int res = 0, kcnt = 0;
        for (int le = 0, ri = 1; le < N; le++) {
            while (ri <= N && preSum[ri]-preSum[le] < tar) ri++;
            ri--;
            res = (res + PPreSum[ri]-PPreSum[le] - preSum[le]*(ri-le)) % MOD;
            kcnt += ri-le;
        }
        res = (res + tar * (k-kcnt)) % MOD;
        return res;
    }

    public int getKth(int k) {  // 第K大的数（来自 子数组和排序后 的数组）
        int low = 0, high = preSum[N];
        while (low < high) {    // 二分查找，所有符合答案右边界
            int mid = low+(high-low)/2;
            int count = getCount(mid);
            if (count < k) low = mid+1;
            else high = mid;
        }
        return low;
    }

    public int getCount(int mid) {   // 双指针，小于等于mid的数的数量
        int count = 0;
        for (int le = 0, ri = 1; le < N; le++) {
            while (ri <= N && preSum[ri]-preSum[le] <= mid) ri++;
            ri--;
            count += ri-le;
        }
        return count;
    }
}
```