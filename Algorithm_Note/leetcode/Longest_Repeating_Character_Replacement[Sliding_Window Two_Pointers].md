#424. 替换后的最长重复字符

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

**示例:**
输入: s = "AABABBA", k = 1
输出: 4
解释:
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。

##滑动窗口

本题可以先退化成考虑K=0的情况，此时题目就变成了求解字符串中最长连续子串长度问题了

我们先可以通过这个特例先了解一下滑动窗口的求解过程（k=0的情况）：

![](../pic/Longest_Repeating_Character_Replacement.png)

上图的求解过程展示中，窗口从左至右不断扩张/滑动，当窗口触达字符串末尾字符时，运算结束，窗口的宽度为最终结果。初始窗口的宽度为1，我们不断的通过向当前窗口覆盖的子串后面追加一个字符看是否能满足我们的要求，如果满足窗口扩张，如果不满足，窗口向右滑动。

当K > 0时，子串的条件变成了允许我们变换子串中的K个字符使其变成一个连续子串。

那么这个题的关键点就是我们如何判断一个字符串改变K个字符，能够变成一个连续串。

如果当前字符串中的出现次数最多的字母个数+K大于串长度，那么这个串就是满足条件的。

我们维护一个数组int[26]来存储当前窗口中各个字母的出现次数，left表示窗口的左边界，right表示窗口右边界。

- 窗口扩张：left不变，right++
- 窗口滑动：left\++，right++

max 保存滑动窗口内相同字母出现次数的历史最大值，通过判断窗口宽度(right - left + 1)是否大于max + K来决定窗口是否做滑动。

理解这题的一个关键是理解 “只要之前每一步问心无愧，逝去的过往就别再回头望”。
```java
class Solution {
    public int characterReplacement(String s, int k) {
        int[] map = new int[26];
        char[] arr = s.toCharArray();
        int max = Integer.MIN_VALUE;
        int le = 0, ri = 0;
        for(; ri < s.length(); ri++) {
            int idx = arr[ri] - 'A';
            max = Math.max(max, ++map[idx]);
            while(ri-le+1 > max+k)	// 这里也可以是 if()
                map[arr[le++]-'A']--;
        }
        return s.length() - le;
    }
}
```
**复杂度分析**

- 时间复杂度：O(N)

- 空间复杂度：O(1)