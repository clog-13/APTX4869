# 1658. 将 x 减到 0 的最小操作数

给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。

如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。

**示例：**
```
输入：nums = [3,2,20,1,1,3], x = 10
输出：5
解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。
```



## 滑动窗口

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int sum = Arrays.stream(nums).sum(), curSum = 0;
        int maxOpt = -1, tarSum = sum-x;
        int le = 0, ri = 0;
        while (le < nums.length) {
            if (ri < nums.length) curSum += nums[ri++];
            while (curSum>tarSum && le<nums.length) curSum -= nums[le++];
            if (curSum == tarSum) maxOpt = Math.max(maxOpt, ri - le);
            if (ri == nums.length) le++;
        }
        return maxOpt == -1 ? -1 : nums.length-maxOpt;
    }
}
```



## 前缀和 + 哈希表

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int sum = 0, tar, res = Integer.MIN_VALUE, preSum = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) sum += num;
        tar = sum - x;
        map.put(0, 0);
        for (int i = 1; i < nums.length+1; i++) {
            preSum += nums[i-1];
            if (!map.containsKey(preSum)) map.put(preSum, i);
            if (map.containsKey(preSum - tar)) {
                res = Math.max(res, i - map.get(preSum - tar));
            } 
        }
        return res == Integer.MIN_VALUE ? -1 : nums.length-res;
    }
}
```

