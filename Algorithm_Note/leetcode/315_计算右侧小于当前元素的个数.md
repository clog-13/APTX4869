# 315. 计算右侧小于当前元素的个数

给定一个整数数组 *nums*，按要求返回一个新数组 *counts*。数组 *counts* 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。 

**示例：**

```
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
```



## 树状数组

```java
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        if (nums.length == 0) return Collections.emptyList();
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for (int val : nums) {
            if (val < min) min = val;
            if (val > max) max = val;
        }

        for (int i = 0; i < nums.length; i++) {
            nums[i] -= min;
        }

        int[] BITree = new int[max - min + 1];
        Integer[] res = new Integer[nums.length];
        for (int i = nums.length-1; i >= 0; i--) {
            res[i] = getSum(nums[i], BITree);
            update(nums[i] + 1, BITree);    // 比当前数大的 数之后如果被查询，右侧小于自己的数量应该 加一
        }
        return Arrays.asList(res);
    }

    private int getSum(int val, int[] BITree) {
        int sum = 0;
        while (val > 0) {
            sum += BITree[val];
            val &= val - 1;
        }
        return sum;
    }

    private void update(int val, int[] BITree) {
        while (val < BITree.length) {
            BITree[val] += 1;
            val += (val & -val);
        }
    }
}
```

树状数组+离散化

```java
class Solution {
    int[] BITree, arr;

    public List<Integer> countSmaller(int[] nums) {
        List<Integer> res = new ArrayList<Integer>(); 
        discretization(nums);
        BITree = new int[nums.length];
        for (int i = nums.length-1; i >= 0; i--) {
            int id = Arrays.binarySearch(arr, nums[i]) + 1;
            res.add(query(id-1));
            update(id);
        }

        Collections.reverse(res);
        return res;
    }

    private void discretization(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        for (int num : nums) set.add(num);
        arr = new int[set.size()];
        int idx = 0;
        for (int num : set) arr[idx++] = num;
        Arrays.sort(arr);
    }

    private void update(int idx) {
        while (idx < BITree.length) {
            BITree[idx] += 1;
            idx += lowBit(idx);
        }
    }

    private int query(int idx) {
        int res = 0;
        while (idx > 0) {
            res += BITree[idx];
            idx -= lowBit(idx);
        }
        return res;
    }
    
    private int lowBit(int x) {
        return x & (-x);
    }
}
```





## 归并排序

同样可以使用 快速排序，但快速排序最坏时间复杂度位O(n^2)

```java
class Solution {
    int[] index, temp, tempIndex, res;

    public List<Integer> countSmaller(int[] nums) {
        index = new int[nums.length];
        temp = new int[nums.length];
        tempIndex = new int[nums.length];
        res = new int[nums.length];
		
        // 未排序数组的每个数的下标(想象每个值领取了一个外号， 方便之后引用，同时起到排序作用)
        for (int i = 0; i < nums.length; i++) index[i] = i; 
        mergeSort(0, nums.length-1, nums);

        List<Integer> list = new ArrayList<>();
        for (int i : res) list.add(i);
        return list;
    }

    private void mergeSort(int le, int ri, int[] arr) {
        if (le >= ri) return;

        int mid = (le+ri) >> 1;
        mergeSort(le, mid, arr);
        mergeSort(mid+1, ri, arr);

        merge(le, ri, arr);
    }

    private void merge(int le, int ri, int[] arr) {
        int mid = (le+ri) >> 1;
        int i = le, j = mid+1, p = le;
        while (i <= mid && j <= ri) {
            if (arr[i] <= arr[j]) {
                res[index[i]] += (j - (mid+1)); // 从它的右侧转移到它左侧的元素的个数

                temp[p] = arr[i];
                tempIndex[p] = index[i];
                i++; p++;                 
            } else {
                // res[index[i]] += (i-le);	// 不能这样写
                
                temp[p] = arr[j];
                tempIndex[p] = index[j];
                j++; p++;
            }
        }

        while (i <= mid) {
            res[index[i]] += (ri - mid);    // 从它的右侧转移到它左侧的元素的个数

            temp[p] = arr[i];
            tempIndex[p] = index[i];
            i++; p++;
        }
        while (j <= ri) {
            res[index[i]] += (mid - le);
            
            temp[p] = arr[j];
            tempIndex[p] = index[j];
            j++; p++;
        }

        for (int k = le; k <= ri; k++) {
            arr[k] = temp[k];
            index[k] = tempIndex[k];
        }
    }
}
```



## 线段树（离散化）

```java
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        List<Integer> res = new LinkedList<>();
        int N = nums.length; if (N == 0) return res;
        
        int st = nums[0], ed = nums[0]; // 获取区间范围
        for (int i = 0; i < N; i++) {
            if (nums[i] < st) st = nums[i];
            if (nums[i] > ed) ed = nums[i];
        }
        
        SegmentTreeNode root = build(st, ed);   //构建树
        for (int i = N-1; i >= 0; i--) {    // 从右向左，边插入边计数
            res.addFirst(query(root, st, nums[i]-1));  // 计数小于该元素的区间，所以要减一
            update(root, nums[i], 1);
        }
        return res;
    }

    private class SegmentTreeNode {
        int st, ed, cnt;
        SegmentTreeNode le, ri;

        public SegmentTreeNode(int st, int ed) {
            this.st = st; this.ed = ed; this.cnt = 0;
            le = null; ri = null;
        }
    }
    
    private SegmentTreeNode build(int st, int ed) {
        if (st > ed) return null;
        SegmentTreeNode root = new SegmentTreeNode(st, ed);
        
        if (st != ed) {
            int mid = (st+ed) >> 1;
            root.le = build(st, mid);
            root.ri = build(mid+1, ed);
        }
        
        return root;
    }

    private void update(SegmentTreeNode root, int tar, int val) {
        if (root.st == root.ed) {
            root.cnt += val;
        } else {
            int mid = (root.st + root.ed) >> 1;
            if (tar <= mid) update(root.le, tar, val);
            else update(root.ri, tar, val);
            root.cnt = root.le.cnt + root.ri.cnt;
        }
    }

    private int query(SegmentTreeNode root, int st, int ed) {
        if (st > ed) return 0;
        if (st <= root.st && root.ed <= ed) {
            return root.cnt;
        }
        
        int mid = (root.st + root.ed) >> 1, res = 0;
        if (st <= mid) res = query(root.le, st, ed);
        if (ed > mid) res += query(root.ri, st, ed);
        return res;
    }
}
```

## 二叉查找树

```java
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        Integer[] res = new Integer[nums.length];
        Arrays.fill(res, 0);
        
        TreeNode root = null;
        for (int i = nums.length-1; i >= 0; i--) {
            root = build(root, new TreeNode(nums[i]), res, i);
        }
        return Arrays.asList(res);
    }

    public TreeNode build(TreeNode root, TreeNode node, Integer[] res, int i) {
        if (root == null) {
            root = node; return root;
        }

        if (root.val >= node.val) {	// 左边
            root.cnt++;
            root.le = build(root.le, node, res, i);
        } else {                    // 右边
            res[i] += root.cnt+1;
            root.ri = build(root.ri, node, res, i);
        }
        return root;
    }
}

class TreeNode {
    int val, cnt;
    TreeNode le, ri;

    public TreeNode(int val) {
        this.val = val; this.cnt = 0;
        le = null; ri = null;
    }
}
```

