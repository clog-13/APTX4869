# 1653. 使字符串平衡的最少删除次数

给你一个字符串 `s` ，它仅包含字符 `'a'` 和 `'b'` 。

你可以删除 `s` 中任意数目的字符，使得 `s` **平衡** 。我们称 `s` **平衡的** 当不存在下标对 `(i,j)` 满足 `i < j` 且 `s[i] = 'b'` 同时 `s[j]= 'a'` 。

请你返回使 `s` **平衡** 的 **最少** 删除次数。

 

**示例 1：**

```
输入：s = "aababbab"
输出：2
解释：你可以选择以下任意一种方案：
下标从 0 开始，删除第 2 和第 6 个字符（"aababbab" -> "aaabbb"），
下标从 0 开始，删除第 3 和第 6 个字符（"aababbab" -> "aabbbb"）。
```

**示例 2：**

```
输入：s = "bbaaaaabb"
输出：2
解释：唯一的最优解是删除最前面两个字符。
```



## 動態規劃

```java
class Solution {
    public int minimumDeletions(String s) {
        int N = s.length();
        int[][] dp = new int[N][2]; // 考虑前 N 个数正確情況下，结尾以 a 和 b 的最小修改次数
        dp[0][0] = s.charAt(0) == 'a' ? 0 : 1;
        dp[0][1] = s.charAt(0) == 'b' ? 0 : 1;
        for (int i = 1; i < N; i++) {
            if (s.charAt(i) == 'a') {
                dp[i][0] = dp[i-1][0];
                dp[i][1] = Math.min(dp[i-1][0], dp[i-1][1]) + 1;
            } else {
                dp[i][1] = Math.min(dp[i-1][0], dp[i-1][1]);
                dp[i][0] = dp[i-1][0] + 1;
            }
        }
        return Math.min(dp[N-1][0], dp[N-1][1]);
    }
}
```

## 前綴和

```java
class Solution {
    public int minimumDeletions(String s) {
        int N = s.length();
        int[] a = new int[N+1], b = new int[N+1];
        for (int i = 0; i < N; i++) {
            a[i+1] = a[i] + (s.charAt(i)=='a' ? 1 : 0);
        }
        for (int i = N-1; i >= 0; i--) {
            b[i] = b[i+1] + (s.charAt(i)=='b' ? 1 : 0);
        }
        int max = 0;
        for (int i = 0; i < N; i++) {
            max = Math.max(max, a[i+1]+b[i]);
        }
        return N-max;
    }
}
```

##  棧

```c
int minimumDeletions(char * s){
    int N = strlen(s), res = 0, b = 0;
    for (int i = 0; i < N; i++) {
        if (s[i] == 'b') {
            b++;
        } else {
            if (b != 0) {
                res++;
                b--;
            }
        }
    }
    return res;
}
```

