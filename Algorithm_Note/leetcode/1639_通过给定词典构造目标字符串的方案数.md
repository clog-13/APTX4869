# 1639. 通过给定词典构造目标字符串的方案数

给你一个字符串列表 `words` 和一个目标字符串 `target` 。`words` 中所有字符串都 **长度相同** 。

你的目标是使用给定的 `words` 字符串列表按照下述规则构造 `target` ：

- 从左到右依次构造 `target` 的每一个字符。
- 为了得到 `target` 第 `i` 个字符（下标从 **0** 开始），当 `target[i] = words[j][k]` 时，你可以使用 `words` 列表中第 `j` 个字符串的第 `k` 个字符。
- 一旦你使用了 `words` 中第 `j` 个字符串的第 `k` 个字符，你不能再使用 `words` 字符串列表中任意单词的第 `x` 个字符（`x <= k`）。也就是说，所有单词下标小于等于 `k` 的字符都不能再被使用。
- 请你重复此过程直到得到目标字符串 `target` 。

**请注意**， 在构造目标字符串的过程中，你可以按照上述规定使用 `words` 列表中 **同一个字符串** 的 **多个字符** 。

请你返回使用 `words` 构造 `target` 的方案数。由于答案可能会很大，请对 `109 + 7` **取余** 后返回。

（译者注：此题目求的是有多少个不同的 `k` 序列，详情请见示例。）

**示例：**

```
输入：words = ["acca","bbbb","caca"], target = "aba"
输出：6
解释：总共有 6 种方法构造目标串。
"aba" -> 下标为 0 ("acca")，下标为 1 ("bbbb")，下标为 3 ("caca")
"aba" -> 下标为 0 ("acca")，下标为 2 ("bbbb")，下标为 3 ("caca")
"aba" -> 下标为 0 ("acca")，下标为 1 ("bbbb")，下标为 3 ("acca")
"aba" -> 下标为 0 ("acca")，下标为 2 ("bbbb")，下标为 3 ("acca")
"aba" -> 下标为 1 ("caca")，下标为 2 ("bbbb")，下标为 3 ("acca")
"aba" -> 下标为 1 ("caca")，下标为 2 ("bbbb")，下标为 3 ("caca")
```



## DP

```java
class Solution {
    public int numWays(String[] words, String target) {
        int N = words[0].length(), M = target.length();
        char[] tar = target.toCharArray();
        long[][] cnt = new long[1010][26], dp = new long[1010][1010];
        for (String w : words) {
            for (int i = 1; i <= N; i++) {
                cnt[i][w.charAt(i-1)-'a']++;    // cnt[i][x]: 第 i 层 x 字符的数量
            }
        }

        dp[0][0] = 1;   // dp[i][t]: 前 i 层构成 target 的前 t 个字符的方案数
        for (int i = 1; i <= N; i++) {
            for (int t = 0; t <= Math.min(i, M); t++) {
                dp[i][t] = dp[i-1][t];
                if (t > 0) dp[i][t] = (dp[i][t] + cnt[i][tar[t-1]-'a']*dp[i-1][t-1]) % 1000000007;
            }
        }

        return (int) dp[N][M];
    }
}
```



## DFS(TLE)

```java
class Solution {
    int res = 0, wLen, tLen;
    
    public int numWays(String[] words, String target) {
		wLen = words[0].length(); tLen = target.length();
        char[] arr = target.toCharArray();
        dfs(0, 0, words, arr);
        
        return res;
    }
    
    private void dfs(int wIdx, int tIdx, String[] words, char[] target) {
        if (tIdx >= target.length) {
            res++; return;
        }
        if (wIdx >= words[0].length() || wLen-wIdx < tLen-tIdx) return;
        
        for (int i = 0; i < words.length; i++) {
            if (words[i].charAt(wIdx) == target[tIdx]) {
                dfs(wIdx+1, tIdx+1, words, target);
            }
        }
        dfs(wIdx+1, tIdx, words, target);
    }
}
```

#