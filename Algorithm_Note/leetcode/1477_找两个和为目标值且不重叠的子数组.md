# 1477. 找两个和为目标值且不重叠的子数组

给你一个整数数组 `arr` 和一个整数值 `target` 。

请你在 `arr` 中找 **两个互不重叠的子数组** 且它们的和都等于 `target` 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 **最小值** 。

请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 **-1** 。

**示例：**

```
输入：arr = [3,1,1,1,5,1,2,1], target = 3
输出：3
解释：注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。
```



## 前缀和 + DP + 双指针

```java
class Solution {
    public int minSumOfLengths(int[] arr, int target) {
        int sum = 0, le = 0, ri = 0;
        int[] dp = new int[arr.length+1];   // dp存的是当前坐标之前的符合tar的最短长度 或没找到(INF)
        dp[0] = 100002;
        int res = 100002;
        while (ri < arr.length) {
            sum += arr[ri++];
            while (sum > target) sum -= arr[le++];

            if (sum == target) {
                dp[ri] = Math.min(dp[ri-1], ri-le);
                if (ri-le + dp[le] < res) res = ri-le + dp[le];
            } else dp[ri] = dp[ri-1];
        }
        if (res == 100002) return -1;
        return res;
    }
}
```



## 前缀和 + DP + 哈希表

```java
class Solution {
    public int minSumOfLengths(int[] arr, int target) {
        int sum = 0, res = 1000002;
        Map<Integer, Integer> map = new HashMap<>();	// 前缀和的最近下标
        map.put(0, 0);
        int[] dp = new int[arr.length+1];	// dp存的是当前坐标之前的符合tar的最短长度 或之前都没有(INF)
        dp[0] = 1000002;
        for (int ri = 1; ri <= arr.length; ri++) {
            dp[ri] = dp[ri-1];
            sum += arr[ri-1];
            int tmp = sum - target;
            if (map.containsKey(tmp)) {	// 找到了一个
                int le = map.get(tmp);
                int cur = ri - le;
                res = Math.min(res, dp[le] + cur);
                dp[ri] = Math.min(dp[ri], cur);
            }
            map.put(sum, ri);
        }
        return res == 1000002 ? -1 : res;
    }
}
```