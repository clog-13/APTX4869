# 1642. 可以到达的最远建筑

给你一个整数数组 `heights` ，表示建筑物的高度。另有一些砖块 `bricks` 和梯子 `ladders` 。

你从建筑物 `0` 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。

当从建筑物 `i` 移动到建筑物 `i+1`（下标 **从 0 开始** ）时：

- 如果当前建筑物的高度 **大于或等于** 下一建筑物的高度，则不需要梯子或砖块
- 如果当前建筑的高度 **小于** 下一个建筑的高度，您可以使用 **一架梯子** 或 **`(h[i+1] - h[i])` 个砖块**

如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 **从 0 开始** ）。

**示例：**

```
输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
输出：4
解释：从建筑物 0 出发，你可以按此方案完成旅程：
- 不使用砖块或梯子到达建筑物 1 ，因为 4 >= 2
- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 < 7
- 不使用砖块或梯子到达建筑物 3 ，因为 7 >= 6
- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 < 9
无法越过建筑物 4 ，因为没有更多砖块或梯子。
```

## 贪心 + 优先队列

优先用梯子,梯子不够就把最短的梯子换成砖头,砖头不够就返回

```java
class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        int res = 0;
        while (res < heights.length-1) {
            if (heights[res] >= heights[res+1]) res++;
            else {
                int v = heights[res+1] - heights[res];
                heap.add(v);
                if (heap.size() > ladders) bricks -= heap.poll();
                if (bricks < 0) return res;
                res++;
            }
        }
        return res;
    }
}
```



二分 + 贪心 + 优先队列

```java
class Solution {
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        int le = ladders, ri = heights.length - 1;
        while (le <= ri) {
            int mid = (le+ri) >> 1;
            if (check(heights, bricks, ladders, mid))
                le = mid + 1;
            else
                ri = mid - 1;
        }
        return ri;
    }
    private boolean check(int[] heights, int bricks, int ladders, int N) {
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        int res = 1;
        while (res <= N) {
            if (heights[res] <= heights[res-1]) res++;
            else {
                int v = heights[res] - heights[res-1];
                heap.add(v);
                if (heap.size() > ladders) bricks -= heap.poll();
                if (bricks < 0) return res-1 == N;
                res++;
            }
        }
        return res-1 == N;
    }
}
```



## DFS(TLE)

```java
class Solution {
    int res = 0;
    public int furthestBuilding(int[] heights, int bricks, int ladders) {
        dfs(heights, 0, bricks, ladders);
        return res;
    }
    private void dfs(int[] heights, int cur, int bricks, int ladders) {
        if (res == heights.length - 1) return;  // 剪枝
        if (cur == heights.length - 1 || (heights[cur+1]-heights[cur] > bricks && ladders==0)) {
            res = Math.max(res, cur);
            return;
        }

        if (heights[cur] >= heights[cur+1]) dfs(heights, cur + 1, bricks, ladders);
        else {
            if (bricks >= heights[cur+1] - heights[cur])
                dfs(heights, cur + 1, bricks + heights[cur] - heights[cur + 1], ladders);
            if (ladders >= 1)
                dfs(heights, cur + 1, bricks, ladders - 1);
        }
    }
}
```

