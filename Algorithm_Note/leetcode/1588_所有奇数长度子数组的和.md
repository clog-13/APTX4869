# 1588. 所有奇数长度子数组的和

给你一个正整数数组 `arr` ，请你计算所有可能的奇数长度子数组的和。

**子数组** 定义为原数组中的一个连续子序列。

请你返回 `arr` 中 **所有奇数长度子数组的和** 。

 **示例：**

```
输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
```



## Math

没有必要求出每种奇数长度数组的情况，只需判断每个元素在奇数长度数组中出现的次数即可

left：对当前元素arr[i]来说，前面有i个元素，想要构成连续数组，可在arr[i]左面连续取0,1,2,...,i个元素，所以共有left=i+1种选择方法

right：arr[i]后有n-i-1个元素，想要构成连续数组，可在arr[i]右面连续取元素，共有right=n-i种选择方法(算上取0个元素)



left_odd, right_odd可选择数：left/2 和 right/2 (左面选奇数个元素，右面选奇数个元素，加上本身后为奇数长度数组)

left_even, right_even可选择数：(left+1)/2 和 (right+1)/2 (左面选偶数个元素，右面选偶数个元素，加上本身后为奇数长度数组)

```java
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
        int length = arr.length, sum = 0;
        for(int i=0;i<length;i++){  //遍历数组
            int left = i+1, right = length-i;
            int le_1 = left/2, ri_1 = right/2;
            int le_2 = (left+1)/2, ri_2 = (right+1)/2;
            sum += arr[i]*(le_1*ri_1 + le_2*ri_2);
        }
        return sum;
    }
}
```

 

## 前缀和

```java
class Solution {
    public int sumOddLengthSubarrays(int[] arr) {
        int N = arr.length, res = 0;
        int[] preSum = new int[N+1];
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i-1]+arr[i-1];
        }

        for (int len = 1; len <= N; len+=2) {
            for (int i = len; i <= N; i++) {
             res += preSum[i] - preSum[i-len];
            }
        }

        return res;
    }
}
```

#