# 线程与进程的区别

**进程的缺点：**在操作系统中，每个进程的内存空间都是独立的，这样用多进程实现并发就有两个缺点：一是内核的管理成本高，二是无法简单地通过内存同步数据，很不方便于是多线程模式就出现了。

- 进程是最小的资源（包括内存、打开的文件等）分配单位，线程是最小的运行单位
- **进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈**
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系（和进程大同小异）
- 线程的创建、终止时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，所以线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们（线程管理的资源较少）
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有**同一个页表，那么在切换的时候不需要切换页表**。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的
- 由于同一进程的**各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了**，这就使得线程之间的数据交互效率更高了
- **线程拥有自己独立的栈和共享的堆，线程的切换一般也由操作系统调度。**
- 同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。
- 对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。

# 协程与线程的区别

1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
2. 线程进程都是同步机制，而协程则是异步
3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态
4. **协程(Coroutine)编译器级的，进程(Process)和线程(Thread)操作系统级的**



# 上下文切换
**进程的上下文切换**

首先进程是由内核管理与调度的，所以 进程上下文切换 **发生在内核态**，进程上下文切换的内容**包含用户空间资源（虚拟内存、栈、全局变量等）与内核空间资源（内核堆栈、寄存器等）。**

在做上下文切换的时候，会把前一个 进程 的上下文保存到它的 PCB 中，然后加载当前 进程 的 PCB 上下文到 CPU 中，使得 进程 继续执行。

CPU把一个进程切换到另一个进程运行的过程，称为进程上下文切换。
CPU上下文 是指 **CPU寄存器** 和 **程序计数器**

**CPU寄存器** 是CPU内置的容量小，速度极快的缓存
**程序计数器** 是用来存储是CPU正在执行的指令位置或即将执行的下一条指令位置

CPU上下文切换 就是把前一个任务的 C P U上下文 保存起来，然后在加载当前任务的 C P U上下文，最后再跳转到 程序计数器 所指的新位置，运行任务。
上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成： 进程上下文切换、线程上下文切换和中断上下文切换。



**线程的上下文切换**

两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，**虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**



# 线程的模型

1. 内核线程：在内核空间就实现的线程，由内核管理
2. 用户线程：在用户空间实现的线程，不归内核管理，是由用户态通过线程库完成线程的管理（用户态是指线程或进程在用户空间运行）
3. 轻量级进程：在内核中来支持用户线程（用户线程与内核线程的中间层，内核线程的高度抽象）
### 内核线程
内核线程是由内核空间管理，所以它的 结构线程控制块（Thread Control Block, TCB） 在内核空间，操作系统对 TCB 是可见的
![](https://segmentfault.com/img/remote/1460000039378423)
### 用户线程
因为 用户线程 在**用户空间，是由 用户态 通过线程库来管理**，所以它的 结构线程控制块（Thread Control Block, TCB） 也是在线程库里面，对于操作系统而言是看不到 TCB 的，它只能看到整个进程的 PCB（内核无法管理用户线程，也感知不到用户线程）
![](https://segmentfault.com/img/remote/1460000039378424)

# 协程

协程就是用户态的线程。通常创建协程时，**会从进程的堆中分配一段内存作为协程的栈。**线程的栈有8MB，而协程栈的大小通常只有几十 KB。而且，C库内存池也不会为协程预分配内存，它感知不到协程的存在。

![终于明白：有了线程，为什么还要有协程？](https://img-blog.csdnimg.cn/img_convert/1f34b6e684fb619253d753ffc0b11daf.png)

![终于明白：有了线程，为什么还要有协程？](https://img-blog.csdnimg.cn/img_convert/9d3a9db459342e8fe0ea4b3a33487504.png)

### 协程缺点

- **在协程执行中不能有阻塞操作，否则整个线程被阻塞(协程是语言级别的，线程，进程属于操作系统级别)**

- **需要特别关注全局变量、对象引用的使用**

- **协程可以处理 IO 密集型程序的效率问题，但是处理 CPU 密集型不是它的长处。**   假设这个线程中有一个协程是 CPU 密集型的他没有 IO 操作，也就是自己不会主动触发调度器调度的过程，那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。

Go 内部有三个对象：

- P (processor) ：代表上下文（或者可以认为是 CPU)
- M (work thread)：代表工作线程
- G：goroutine

```text
type g struct {
    stack       stack  

    stackguard0 uintptr 
    stackguard1 uintptr 
    ......

    sched       gobuf

    ......
}
// gobuf记录与协程切换相关信息 
type gobuf struct {
    sp   uintptr 
    pc   uintptr 
    g    guintptr

    ctxt unsafe.Pointer 

    ret  uintreg

    lr   uintptr 
    bp   uintptr 
}
```



### 轻量级进程（Light-weight process，LWP）

轻量级进程（Light-weight process，LWP）可以理解成内核线程的高级抽象，一个 进程 可以有一个或多个L W P ，因为每个 L W P 与 内核线程 一对一映射，所以 L W P 都是由一个 内核线程 支持（用户线程关联L W P，即成为内核支持的用户线程）。

在大多数系统中，L W P与 普通进程 的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个进程 代表程序的一个实例，而 L W P 代表程序的执行线程，因为一个 执行线程 不像进程那样需要那么多状态信息，所以 L W P 也不带有这样的信息。

#### 一对一模型（内核级线程模型）

L W P就是一对一模型，即 进程 只需要创建使用L W P ，因为一个 L W P 由一个 内核线 程支持，所以最终是内核管理线程，可以调度到其他处理器上（再简单点解释，直接使用内核线程）

![img](https://segmentfault.com/img/remote/1460000039378425)

一对一模型（1:1）的优缺点就不多说了，上面介绍内核线程的时候已经说过了，但是值得一提的是，jvm采用该模型实现线程，所以在Java中启动一个线程需要谨慎

#### 一对多模型（用户级线程模型）

一对多模型，即多个用 户级线程 对用到同一个 L W P 上实现，因为是用户态通过用户空间的线程库对线程管理，所以速度特别快，不会涉及到用户态与内核态的转换

![img](https://segmentfault.com/img/remote/1460000039378426)

一对多模型（n:1）的优点缺点体现在用户级线程上面，用户线程的优缺点前面说过，这里不做概述，值得一提的是 Python 中的协程就是通过该模型实现。

#### 多对多模型（两级线程模型）

多对多模型是集各家所长诞生的产物，它充分吸收前两种线程模型的优点且尽量避免它们的缺点。

首先它区别于多对一模型，多对多模型进程内的 多用户线程 可以绑定不同的内核线程 ，这点与 一对一模型 类似，其次又区别于一对一模型，进程内的 多用户线程 与 内核线程 不是一对一绑定，而是动态绑定，当某个 内核线程 因绑定的 用户线程 执行阻塞操作，让出 C P U 时，绑定该 内核线程 的其他 用户线程 可以解绑，重新绑定到其他 内核线程 继续运行。

所以多对多模型（m:n），即不是多对一模型完全靠自己实现的线程库调度，也不是一对一模型完全靠操作系统调度，而是一个中间态系统（负责自身调度与操作系统调度的协同工作），最后提一句Go语言使用的是多对多模型，这也是其高并发的原因，它的线程模型与Java中的ForkJoinPool非常类似。

![img](https://segmentfault.com/img/remote/1460000039378428)

多对多模型优点

- 兼具多对一模型的轻量
- 由于对应了多个内核线程，则一个用户线程阻塞时，其他用户线程仍然可以执行
- 由于对应了多个内核线程，则可以实现较完整的调度、优先级等；

多对多模型缺点

- 实现复杂（因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现）
